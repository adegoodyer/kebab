#!/bin/bash
#
# Author:       Ade Goodyer
# Date:         20th Sept 2023
# Description:  recursively change snake case directories and filenames to kebab case
# Example:      an_example_dir -> an-example-dir
#               an_example_file.md -> an-example-file.md
#

# Function to convert snake_case to kebab-case
snake_to_kebab() {
  echo "$1" | sed -E 's/([a-z0-9])_+([a-z0-9])/\1-\2/g; s/_/-/g'
}

# Initialize flags
rename_directories=false
rename_files=false
rename_both=false
find_empty_dirs=false
delete_empty_dirs=false

# Function to display usage message
usage() {
  cat <<EOF
Usage: $0 [--dir] [--files] [--all] [--empty] [--del-empty] [--help]

Options:
  --dir        Rename directories with snake_case names to kebab_case.
  --files      Rename files with snake_case names to kebab_case.
  --all        Rename both directories and files with snake_case names to kebab_case.
  --empty      Find empty directories.
  --del-empty  Find and delete empty directories (use with --empty).
  --help       Display this help message.
EOF
  exit 0
}

# Parse command-line flags
while [[ $# -gt 0 ]]; do
  case "$1" in
  --dir)
    rename_directories=true
    ;;
  --files)
    rename_files=true
    ;;
  --all)
    rename_both=true
    ;;
  --empty)
    find_empty_dirs=true
    ;;
  --del-empty)
    delete_empty_dirs=true
    ;;
  --help)
    usage
    ;;
  *)
    echo "Invalid option: $1" >&2
    exit 1
    ;;
  esac
  shift
done

# Check if no flags are specified
if [ "$rename_directories" = false ] && [ "$rename_files" = false ] && [ "$rename_both" = false ] && [ "$find_empty_dirs" = false ] && [ "$delete_empty_dirs" = false ]; then
  echo "Please specify at least one of the options. Use --help for help."
  exit 1
fi

# Function to find and rename directories
rename_directories() {
  directories_to_rename=()
  while IFS= read -r -d '' dir; do
    directories_to_rename+=("$dir")
  done < <(find . -type d -name '*_*' -print0)

  if [ ${#directories_to_rename[@]} -eq 0 ]; then
    echo "No directories with snake_case names found."
    return
  fi

  # Output directories that will be renamed
  echo "Directories that will be renamed:"
  for dir in "${directories_to_rename[@]}"; do
    # Get the parent directory and name of the directory
    parent_dir=$(dirname "$dir")
    base_dir=$(basename "$dir")

    # Convert snake_case to kebab-case
    kebab_case=$(snake_to_kebab "$base_dir")

    # Output the old and new directory names
    echo "$dir -> $parent_dir/$kebab_case"
  done

  # Ask for confirmation
  read -p "Do you want to proceed with renaming these directories? (y/n): " confirm
  if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
    echo "Operation canceled."
    return
  fi

  # Rename the directories
  for dir in "${directories_to_rename[@]}"; do
    # Get the parent directory and name of the directory
    parent_dir=$(dirname "$dir")
    base_dir=$(basename "$dir")

    # Convert snake_case to kebab-case
    kebab_case=$(snake_to_kebab "$base_dir")

    # Rename the directory with kebab-case
    mv "$dir" "$parent_dir/$kebab_case"
    echo "Renamed: $dir -> $parent_dir/$kebab_case"
  done
}

# Function to find and rename files
rename_files() {
  files_to_rename=()
  while IFS= read -r -d '' file; do
    files_to_rename+=("$file")
  done < <(find . -type f -name '*_*' -print0)

  if [ ${#files_to_rename[@]} -eq 0 ]; then
    echo "No files with snake_case names found."
    return
  fi

  # Output files that will be renamed
  echo "Files that will be renamed:"
  for file in "${files_to_rename[@]}"; do
    # Get the directory and base name of the file
    dir=$(dirname "$file")
    base=$(basename "$file")

    # Convert snake_case to kebab-case
    kebab_case=$(snake_to_kebab "$base")

    # Output the old and new file names
    echo "$file -> $dir/$kebab_case"
  done

  # Ask for confirmation
  read -p "Do you want to proceed with renaming these files? (y/n): " confirm
  if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
    echo "Operation canceled."
    return
  fi

  # Rename the files
  for file in "${files_to_rename[@]}"; do
    # Get the directory and base name of the file
    dir=$(dirname "$file")
    base=$(basename "$file")

    # Convert snake_case to kebab-case
    kebab_case=$(snake_to_kebab "$base")

    # Rename the file with kebab-case
    mv "$file" "$dir/$kebab_case"
    echo "Renamed: $file -> $dir/$kebab_case"
  done
}

# Function to find empty directories
find_empty_directories() {
  find . -type d -empty
}

# Function to delete empty directories
delete_empty_directories() {
  find . -type d -empty -delete
}

# If --empty option is specified, find empty directories
if [ "$find_empty_dirs" = true ]; then
  echo "Empty directories found:"
  find_empty_directories
fi

# If --del-empty option is specified with --empty, delete empty directories
if [ "$delete_empty_dirs" = true ] && [ "$find_empty_dirs" = true ]; then
  read -p "Do you want to proceed with deleting these empty directories? (y/n): " confirm
  if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
    delete_empty_directories
    echo "Empty directories deleted."
  else
    echo "Operation canceled."
  fi
fi

# If --all option is specified, rename directories first and rescan before renaming files
if [ "$rename_both" = true ]; then
  rename_directories
  # Rescan the directory for files
  rename_files
else
  if [ "$rename_directories" = true ]; then
    rename_directories
  fi

  if [ "$rename_files" = true ]; then
    rename_files
  fi
fi

echo "Renaming completed."
